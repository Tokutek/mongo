# -*- python -*-
# ex: set syntax=python:

import itertools
import os
import os.path
import re
import stat

import secrets

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot import buildslave

c['slaves'] = [buildslave.BuildSlave('lex1', secrets.passwds['lex1'],
                                     properties={'ncpus': 4,
                                                 'system': 'linux',
                                                 'machine': 'x86_64',
                                                 'env': {
                                                     'CC': 'gcc47',
                                                     'CXX': 'g++47',
                                                     'CPATH': '/usr/local/valgrind-3.8.1/include:${CPATH}'
                                                 }})]

vms = []
mindy_slaves = []
for i in range(4):
    name = 'cavil-docker-%d' % i
    c['slaves'].append(buildslave.BuildSlave(name, secrets.passwds[name],
                                             max_builds=1,
                                             properties={'ncpus': 2,
                                                         'system': 'linux',
                                                         'machine': 'x86_64',
                                                         'env': {
                                                             'CC': 'gcc-4.7',
                                                             'CXX': 'g++-4.7'
                                                         }}))
    vms.append(name)
for i in range(16):
    name = 'mindy-docker-%d' % i
    c['slaves'].append(buildslave.BuildSlave(name, secrets.passwds['mindy-docker-0'],
                                             max_builds=1,
                                             properties={'ncpus': 4,
                                                         'system': 'linux',
                                                         'machine': 'x86_64',
                                                         'env': {
                                                             'CC': 'gcc-4.7',
                                                             'CXX': 'g++-4.7'
                                                         }}))
    vms.append(name)
    mindy_slaves.append(name)

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

all_repositories = {('git://github.com/Tokutek/%s.git' % x): x for x in [
    'mongo',
    'ft-index',
    'jemalloc',
    'backup-community',
    'mongo-python-driver',
    'mongo-ruby-driver',
    'mongo-java-driver',
    'mongo-perl-driver']}
backup_enterprise_url = '%s/Tokutek/backup-enterprise.git' % secrets.private_github_url
all_repositories[backup_enterprise_url] = 'backup-enterprise'
backup_plugin_url = '%s/Tokutek/tokumx-backup-plugin.git' % secrets.private_github_url
all_repositories[backup_plugin_url] = 'tokumx-backup-plugin'

def codebaseGenerator(chdict):
    return all_repositories[chdict['repository']]

c['codebaseGenerator'] = codebaseGenerator

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

from buildbot.changes import gitpoller
c['change_source'] = []
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/mongo.git', workdir='gitpoller-mongo', branches=['master', 'releases/tokumx-1.2', 'releases/tokumx-1.3'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/ft-index.git', workdir='gitpoller-ft-index', branches=['master', 'releases/tokumx-1.2', 'releases/tokumx-1.3'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/jemalloc.git', workdir='gitpoller-jemalloc', branches=['3.3.1'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/backup-community.git', workdir='gitpoller-mongo', branches=['master', 'releases/tokumx-1.2', 'releases/tokumx-1.3'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller(backup_enterprise_url, workdir='gitpoller-mongo', branches=['master', 'releases/tokumx-1.2', 'releases/tokumx-1.3'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller(backup_plugin_url, workdir='gitpoller-mongo', branches=['master', 'releases/tokumx-1.2', 'releases/tokumx-1.3'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/mongo-python-driver.git', workdir='gitpoller-mongo-python-driver', branches=['master'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/mongo-ruby-driver.git', workdir='gitpoller-mongo-ruby-driver', branches=['master'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/mongo-java-driver.git', workdir='gitpoller-mongo-java-driver', branches=['master'], pollinterval=300))
c['change_source'].append(gitpoller.GitPoller('git://github.com/Tokutek/mongo-perl-driver.git', workdir='gitpoller-mongo-perl-driver', branches=['master'], pollinterval=300))

def gen_codebases(branch, enterprise, with_drivers):
    codebases = {'mongo': {'repository': 'git://github.com/Tokutek/mongo.git', 'branch': branch},
                 'ft-index': {'repository': 'git://github.com/Tokutek/ft-index.git', 'branch': branch},
                 'jemalloc': {'repository': 'git://github.com/Tokutek/jemalloc.git', 'branch': '3.3.1'}}
    if enterprise:
        codebases.update({'backup-enterprise': {'repository': backup_enterprise_url, 'branch': branch},
                          'tokumx-backup-plugin': {'repository': backup_plugin_url, 'branch': branch}})
    else:
        codebases.update({'backup-community': {'repository': 'git://github.com/Tokutek/backup-community.git', 'branch': branch}})
    if with_drivers:
        codebases.update({'mongo-python-driver': {'repository': 'git://github.com/Tokutek/mongo-python-driver.git', 'branch': 'master'},
                          'mongo-ruby-driver': {'repository': 'git://github.com/Tokutek/mongo-ruby-driver.git', 'branch': 'master'},
                          'mongo-java-driver': {'repository': 'git://github.com/Tokutek/mongo-java-driver.git', 'branch': 'master'},
                          'mongo-perl-driver': {'repository': 'git://github.com/Tokutek/mongo-perl-driver.git', 'branch': 'master'}})
    return codebases

all_codebases = {'mongo': {'repository': 'git://github.com/Tokutek/mongo.git'},
                 'ft-index': {'repository': 'git://github.com/Tokutek/ft-index.git'},
                 'jemalloc': {'repository': 'git://github.com/Tokutek/jemalloc.git'},
                 'backup-community': {'repository': 'git://github.com/Tokutek/backup-community.git'},
                 'backup-enterprise': {'repository': backup_enterprise_url},
                 'tokumx-backup-plugin': {'repository': backup_plugin_url},
                 'mongo-python-driver': {'repository': 'git://github.com/Tokutek/mongo-python-driver.git', 'branch': 'master'},
                 'mongo-ruby-driver': {'repository': 'git://github.com/Tokutek/mongo-ruby-driver.git', 'branch': 'master'},
                 'mongo-java-driver': {'repository': 'git://github.com/Tokutek/mongo-java-driver.git', 'branch': 'master'},
                 'mongo-perl-driver': {'repository': 'git://github.com/Tokutek/mongo-perl-driver.git', 'branch': 'master'}}

def mergeRequests(builder, req1, req2):
    for prop in ['debugbuild', 'enterprise']:
        if req1.properties.hasProperty(prop) != req2.properties.hasProperty(prop):
            return False
        if req1.properties.hasProperty(prop) and req1.properties.getProperty(prop) != req2.properties.getProperty(prop):
            return False
    return req1.canBeMergedWith(req2)

c['mergeRequests'] = mergeRequests

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot import locks
from buildbot.process import buildstep, factory, properties
from buildbot.steps import shell, slave, transfer, trigger
from buildbot.steps.source import git

jN = properties.Interpolate('-j%(prop:ncpus:-1)s')
scons_build_type = properties.Interpolate('%(prop:debugbuild:#?|--dd|--release)s')
scons_gcov_flags = properties.Interpolate('%(prop:coveragebuild:#?|--gcov|)s')
scons_cc_flag = properties.Interpolate('%(prop:coveragebuild:#?|--cc=gcc-4.6|)s')
scons_cxx_flag = properties.Interpolate('%(prop:coveragebuild:#?|--cxx=g++-4.6|)s')

@properties.renderer
def scons_tokukv_version(props):
    s = '--force-toku-version='
    if not props.hasProperty('got_revision'):
        s += 'notokukvversion'
    rev = props.getProperty('got_revision')
    if 'ft-index' not in rev:
        s += 'notokukvversion'
    else:
        s += rev['ft-index']
    return s

from buildbot.status import results
def skipped(res, step):
    return res == results.SKIPPED
def success(res, step):
    return res == results.SUCCESS

def community_backup(step):
    props = step.build.getProperties()
    if props.hasProperty('enterprise'):
        return not props.getProperty('enterprise')
    return False

def enterprise_backup(step):
    props = step.build.getProperties()
    if props.hasProperty('enterprise'):
        return props.getProperty('enterprise')
    return False

checkout_steps = [git.Git(name='update mongo', codebase='mongo', repourl='git://github.com/Tokutek/mongo.git', mode='incremental', hideStepIf=success),
                  git.Git(name='update ft-index', codebase='ft-index', repourl='git://github.com/Tokutek/ft-index.git', mode='incremental', workdir='build/src/third_party/ft-index', hideStepIf=success),
                  git.Git(name='update jemalloc', codebase='jemalloc', repourl='git://github.com/Tokutek/jemalloc.git', mode='incremental', workdir='build/src/third_party/ft-index/third_party/jemalloc', hideStepIf=success),
                  git.Git(name='update backup', codebase='backup-community', repourl='git://github.com/Tokutek/backup-community.git', mode='incremental', workdir='build/src/third_party/backup-community', doStepIf=community_backup, hideStepIf=lambda r,s: skipped(r,s) or success(r,s)),
                  git.Git(name='update backup', codebase='backup-enterprise', repourl=backup_enterprise_url, mode='incremental', workdir=properties.Interpolate('build/src/third_party/backup-enterprise'), doStepIf=enterprise_backup, hideStepIf=lambda r,s: skipped(r,s) or success(r,s)),
                  git.Git(name='update backup plugin', codebase='tokumx-backup-plugin', repourl=backup_plugin_url, mode='incremental', workdir='build/src/mongo/plugins/tokumx-backup-plugin', doStepIf=enterprise_backup, hideStepIf=lambda r,s: skipped(r,s) or success(r,s))]

build_ft_index = [shell.Configure(name='configure ft-index',
                                  descriptionSuffix=['ft-index'],
                                  command=['cmake',
                                           '-DUSE_BDB=OFF',
                                           '-DBUILD_TESTING=OFF',
                                           '-DUSE_CTAGS=OFF',
                                           '-DUSE_CSCOPE=OFF',
                                           '-DUSE_GTAGS=OFF',
                                           '-DUSE_ETAGS=OFF',
                                           '-DCMAKE_LINK_DEPENDS_NO_SHARED=ON',
                                           '-DCMAKE_INSTALL_PREFIX=../../tokukv',
                                           properties.Interpolate('-DTOKU_DEBUG_PARANOID=%(prop:debugbuild:#?|ON|OFF)s'),
                                           properties.Interpolate('-DUSE_VALGRIND=%(prop:debugbuild:#?|ON|OFF)s'),
                                           properties.Interpolate('-DCMAKE_BUILD_TYPE=%(prop:debugbuild:#?|Debug|Release)s'),
                                           '..'],
                                  env=properties.Property('env'),
                                  workdir=properties.Interpolate('build/src/third_party/ft-index/%(prop:debugbuild:#?|dbg|opt)s')),
                  shell.Compile(name='compile ft-index',
                                descriptionSuffix=['ft-index'],
                                timeout=7200,
                                command=['cmake',
                                         '--build',
                                         properties.Interpolate('src/third_party/ft-index/%(prop:debugbuild:#?|dbg|opt)s'),
                                         '--target',
                                         'install',
                                         '--',
                                         jN],
                                warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                                warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                                suppressionFile='buildbot/compile.suppressions',
                                env=properties.Property('env'))]

build_backup = [shell.Configure(name='configure backup',
                                descriptionSuffix=['backup'],
                                command=['cmake',
                                         '-DBUILD_TESTING=OFF',
                                         '-DUSE_CTAGS=OFF',
                                         '-DUSE_ETAGS=OFF',
                                         '-DUSE_GCOV=OFF',
                                         '-DBACKUP_HAS_PARENT=OFF',
                                         '-DCMAKE_LINK_DEPENDS_NO_SHARED=ON',
                                         '-DHOT_BACKUP_LIBNAME=HotBackup',
                                         '-DCMAKE_INSTALL_PREFIX=../../../tokubackup',
                                         properties.Interpolate('-DCMAKE_BUILD_TYPE=%(prop:debugbuild:#?|ON|OFF)s'),
                                         '..'],
                                env=properties.Property('env'),
                                workdir=properties.Interpolate('build/src/third_party/backup-%(prop:enterprise:#?|enterprise|community)s/backup/%(prop:debugbuild:#?|dbg|opt)s'),
                                hideStepIf=skipped),
                shell.Compile(name='compile backup',
                              descriptionSuffix=['backup'],
                              command=['cmake',
                                       '--build',
                                       properties.Interpolate('src/third_party/backup-%(prop:enterprise:#?|enterprise|community)s/backup/%(prop:debugbuild:#?|dbg|opt)s'),
                                       '--target',
                                       'install',
                                       '--',
                                       jN],
                              warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                              warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                              suppressionFile='buildbot/compile.suppressions',
                              env=properties.Property('env'),
                              hideStepIf=skipped)]

def dn(props):
    enterprise = props.hasProperty('enterprise') and props.getProperty('enterprise')
    if props.hasProperty('distname') and props.getProperty('distname') and len(props.getProperty('distname')):
        s = props.getProperty('distname')
        if enterprise:
            s += '-e'
        return s
    else:
        rev = props.getProperty('got_revision')
        if enterprise:
            s = 'e-'
        else:
            s = ''
        s += rev['mongo'][:7] + '-ft-' + rev['ft-index'][:7]
        if enterprise:
            s += '-ba-' + rev['backup-enterprise'][:7] + '-bp-' + rev['tokumx-backup-plugin'][:7]
        return s

@properties.renderer
def distname(props):
    return '--distname=' + dn(props)

def _installdir(props):
    s = ('tokumx-' + dn(props) +
         '-' + props.getProperty('system') +
         '-' + props.getProperty('machine'))
    if props.getProperty('debugbuild'):
        s += '-debug'
    return s

@properties.renderer
def installdir(props):
    return _installdir(props)

def _tarball(props):
    return _installdir(props) + '.tgz'

@properties.renderer
def tarball(props):
    return _tarball(props)

def _md5(props):
    return _tarball(props) + '.md5'

@properties.renderer
def md5(props):
    return _md5(props)

def _cksum_tarball_command(props):
    return 'md5sum %s > %s' % (_tarball(props), _md5(props))

@properties.renderer
def cksum_tarball_command(props):
    return _cksum_tarball_command(props)

def _verify_md5_command(props):
    return 'md5sum --check ' + _md5(props)

@properties.renderer
def verify_md5_command(props):
    return _verify_md5_command(props)

def _dest_tarball(props):
    return os.path.join('builds', _tarball(props))

@properties.renderer
def dest_tarball(props):
    return _dest_tarball(props)

def _dest_md5(props):
    return _dest_tarball(props) + '.md5'

@properties.renderer
def dest_md5(props):
    return _dest_md5(props)

def _debuginfo_tarball(props):
    return _installdir(props) + '-debuginfo.tgz'

@properties.renderer
def debuginfo_tarball(props):
    return _debuginfo_tarball(props)

def _debuginfo_md5(props):
    return _debuginfo_tarball(props) + '.md5'

@properties.renderer
def debuginfo_md5(props):
    return _debuginfo_md5(props)

def _cksum_debuginfo_tarball_command(props):
    return 'md5sum %s > %s' % (_debuginfo_tarball(props), _debuginfo_md5(props))

@properties.renderer
def cksum_debuginfo_tarball_command(props):
    return _cksum_debuginfo_tarball_command(props)

def _dest_debuginfo_tarball(props):
    return os.path.join('builds', _debuginfo_tarball(props))

@properties.renderer
def dest_debuginfo_tarball(props):
    return _dest_debuginfo_tarball(props)

def _dest_debuginfo_md5(props):
    return _dest_debuginfo_tarball(props) + '.md5'

@properties.renderer
def dest_debuginfo_md5(props):
    return _dest_debuginfo_md5(props)

build_mongo = shell.Compile(name='compile mongo',
                            descriptionSuffix=['mongo'],
                            warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                            warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                            suppressionFile='buildbot/compile.suppressions',
                            timeout=7200,
                            command=['scons',
                                     scons_build_type,
                                     scons_gcov_flags,
                                     scons_cc_flag,
                                     scons_cxx_flag,
                                     scons_tokukv_version,
                                     jN,
                                     '--skip-tarballs',
                                     '.'])

quick_compile_factory = factory.BuildFactory()
quick_compile_factory.addSteps(checkout_steps)
quick_compile_factory.addSteps(build_ft_index)
quick_compile_factory.addSteps(build_backup)
quick_compile_factory.addStep(build_mongo)

build_mongo_tarballs = [shell.Compile(name='compile mongo',
                                      descriptionSuffix=['mongo'],
                                      warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                                      warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                                      suppressionFile='buildbot/compile.suppressions',
                                      timeout=7200,
                                      command=['scons',
                                               scons_build_type,
                                               scons_tokukv_version,
                                               jN,
                                               distname,
                                               '.']),
                        shell.ShellCommand(command=['bash', '-c', cksum_tarball_command], hideStepIf=success),
                        shell.ShellCommand(command=['bash', '-c', cksum_debuginfo_tarball_command], hideStepIf=success)]

def build_tarball_factory():
    f = factory.BuildFactory()
    f.addStep(slave.RemoveDirectory(dir='build/src/mongo/plugins/tokumx-backup-plugin', hideStepIf=True, haltOnFailure=False, flunkOnFailure=False))
    f.addSteps(checkout_steps)
    f.addSteps(build_ft_index)
    f.addSteps(build_backup)
    f.addSteps(build_mongo_tarballs)
    for src, dest in [(tarball, dest_tarball),
                      (debuginfo_tarball, dest_debuginfo_tarball),
                      (md5, dest_md5),
                      (debuginfo_md5, dest_debuginfo_md5)]:
        f.addStep(transfer.FileUpload(slavesrc=src, masterdest=dest, mode=(stat.S_IRUSR|stat.S_IWUSR|stat.S_IRGRP|stat.S_IROTH)))
        f.addStep(shell.ShellCommand(command=['rm', src], hideStepIf=success))
    return f

def build_tarball_and_trigger_test_factory(enterprise, debugbuild):
    f = build_tarball_factory()
    name = 'release_test-'
    name += 'e-' if enterprise else 'c-'
    name += 'dbg' if debugbuild else 'opt'
    f.addStep(trigger.Trigger(schedulerNames=[name],
                              waitForFinish=False,
                              updateSourceStamp=True,
                              set_properties={'distname': properties.Property('distname')}))
    return f

# protects /tmp/unittest which is hard-coded into dbtests.cpp
unittest_lock = locks.SlaveLock("unittest_lock", maxCount=1)

class TAPLogObserver(buildstep.LogLineObserver):
    _tap_re = re.compile(r'(ok|not ok)(?: ([0-9]*)(?: ([^#]*)(?:#(.*))?)?)? ')
    tests = 0

    def outLineReceived(self, line):
        m = self._tap_re.match(line.strip())
        if m:
            gs = m.groups()
            self.tests += 1
            self.step.setProgress('tests', self.tests)

def locks_for_smoke(target):
    if target in ['smoke']:
        return [unittest_lock.access('exclusive')]
    return []

@properties.renderer
def smoke_port(props):
    return '--smoke-port=%d' % (32000 + props.getProperty('port_inc'))
def scons_smoke(target, with_auth):
    name = target
    if with_auth:
        name += '-auth'
    prefix = properties.Interpolate('--smokedbprefix=smoke-%(prop:buildername)s-' + name)
    cmd = ['scons',
           scons_build_type,
           scons_tokukv_version,
           prefix,
           smoke_port,
           '--smoke-quiet',
           '--skip-tarballs']
    if with_auth:
        cmd.append('--smokeauth')
    cmd.append(target)
    step = shell.Test(name=name,
                      descriptionSuffix=[name],
                      command=cmd,
                      locks=locks_for_smoke(target),
                      warningPattern=re.compile(r'(?!)'),  # matches no string, we don't want to see warnings from the mongod error log
                      env=properties.Property('env'))
    step.addLogObserver('stdio', TAPLogObserver())
    return [slave.MakeDirectory(dir=properties.Interpolate('build/smoke-%(prop:buildername)s-' + name), hideStepIf=success), step]
cpp_tests = list(itertools.chain(*[scons_smoke(x, y)
                                   for y in [False, True]
                                   for x in ['smoke', 'smokeCppUnittests', 'smokeClient', 'mongosTest']]))

# protects js tests that spawn mongods with hard-coded port numbers
sets_lock = locks.SlaveLock("sets_lock", maxCount=1)
def locks_for_suite(suite):
    if suite in ['auth', 'sharding', 'replSets', 'jsSlowNightly', 'jsSlowWeekly', 'tool']:
        return [sets_lock.access('exclusive')]
    else:
        return []

def not_perf_or_not_debugbuild(step):
    if step.name[:6] != 'jsPerf':
        return True
    else:
        props = step.build.getProperties()
        if props.hasProperty('debugbuild'):
            return not props.getProperty('debugbuild')
        else:
            return True

@properties.renderer
def port(props):
    return '--port=%d' % (32000 + props.getProperty('port_inc'))
def smoke_suite(suite, with_auth):
    if suite == 'auth' and with_auth:
        # skip this, it won't run anything
        return []

    name = suite
    if with_auth:
        name += '-auth'
    prefix = properties.Interpolate('--smoke-db-prefix=smoke-%(prop:buildername)s-' + name)
    cmd = ['python2',
           'buildscripts/smoke.py',
           prefix,
           port,
           '--continue-on-failure',
           '--quiet',
           '--smoke-server-opts=--logappend']
    if with_auth:
        cmd.append('--auth')
    cmd.append(suite)
    step = shell.Test(name=name,
                      descriptionSuffix=[name],
                      command=cmd,
                      locks=locks_for_suite(suite),
                      timeout=7200,
                      warningPattern=re.compile(r'(?!)'),  # matches no string, we don't want to see warnings from the mongod error log
                      logfiles={'tests': properties.Interpolate('smoke-%(prop:buildername)s-' + name + '/tests.log'),
                                'server': properties.Interpolate('smoke-%(prop:buildername)s-' + name + '/server.log')},
                      doStepIf=not_perf_or_not_debugbuild,
                      env=properties.Property('env'))
    step.addLogObserver('stdio', TAPLogObserver())
    step.progressMetrics += ('tests',)
    return [slave.MakeDirectory(dir=properties.Interpolate('build/smoke-%(prop:buildername)s-' + name), doStepIf=not_perf_or_not_debugbuild, hideStepIf=success),
            step,
            slave.RemoveDirectory(dir=properties.Interpolate('build/smoke-%(prop:buildername)s-' + name), doStepIf=not_perf_or_not_debugbuild, alwaysRun=True, hideStepIf=True, haltOnFailure=False, flunkOnFailure=False)]

class TriggerIfTarballMissing(trigger.Trigger):
    def doStepIf(self, step):
        props = self.build.getProperties()
        if props.hasProperty('got_revision'):
            return not os.path.exists(_dest_tarball(props))
        else:
            return False

get_tarball = [TriggerIfTarballMissing(schedulerNames=['tarball'],
                                       hideStepIf=skipped,
                                       waitForFinish=True,
                                       haltOnFailure=True,
                                       updateSourceStamp=True,
                                       set_properties={'enterprise': properties.Property('enterprise'),
                                                       'debugbuild': properties.Property('debugbuild'),
                                                       'coveragebuild': properties.Property('coveragebuild'),
                                                       'distname': properties.Property('distname')}),
               transfer.FileDownload(mastersrc=dest_tarball, slavedest=tarball, hideStepIf=success),
               transfer.FileDownload(mastersrc=dest_md5, slavedest=md5, hideStepIf=success),
               shell.ShellCommand(name='verify checksum', description=['verifying', 'checksum'], descriptionDone=['verify', 'checksum'],
                                  command=['bash', '-c', verify_md5_command], hideStepIf=success, flunkOnFailure=True, haltOnFailure=True)]

unpack_tarball = [slave.MakeDirectory(dir='build/mongo-tarball', hideStepIf=success),
                  shell.ShellCommand(name='unpack tarball',
                                     description=['unpacking', 'tarball'],
                                     descriptionDone=['unpack', 'tarball'],
                                     command=['tar', 'xzf', tarball,
                                              '-C', 'mongo-tarball',
                                              '--strip-components', '1'],
                                     haltOnFailure=True, hideStepIf=success),
                  shell.ShellCommand(command=['rm', tarball, md5], hideStepIf=success),
                  shell.ShellCommand(name='link binaries',
                                     command=['bash', '-c',
                                              'for bin in $(ls mongo-tarball/bin); do ln -snf mongo-tarball/bin/$bin .; done'],
                                     hideStepIf=success)]

build_test_extras = shell.Compile(name='compile mongobridge',
                                  descriptionSuffix=['mongobridge'],
                                  warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                                  warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                                  suppressionFile='buildbot/compile.suppressions',
                                  command=['scons',
                                           scons_build_type,
                                           scons_tokukv_version,
                                           jN,
                                           '--skip-tarballs',
                                           'mongobridge'],
                                  hideStepIf=success)

just_driver_repos = [git.Git(name='update mongo-python-driver', codebase='mongo-python-driver', repourl='git://github.com/Tokutek/mongo-python-driver.git', mode='incremental', workdir='mongo-python-driver', hideStepIf=success),
                     git.Git(name='update mongo-ruby-driver', codebase='mongo-ruby-driver', repourl='git://github.com/Tokutek/mongo-ruby-driver.git', mode='incremental', workdir='mongo-ruby-driver', hideStepIf=success),
                     git.Git(name='update mongo-java-driver', codebase='mongo-java-driver', repourl='git://github.com/Tokutek/mongo-java-driver.git', mode='incremental', workdir='mongo-java-driver', hideStepIf=success),
                     git.Git(name='update mongo-perl-driver', codebase='mongo-perl-driver', repourl='git://github.com/Tokutek/mongo-perl-driver.git', mode='incremental', workdir='mongo-perl-driver', hideStepIf=success)]


class PymongoLogObserver(buildstep.LogLineObserver):
    _line_re = re.compile(r'(\w+)  \(([.\w]+)\) \.\.\. (ok|SKIP|ERROR|FAIL)')
    tests = 0

    def errLineReceived(self, line):
        m = self._line_re.search(line.strip())
        if m:
            name, suite, result = m.groups()
            self.tests += 1
            self.step.setProgress('tests', self.tests)

class RubyLogObserver(buildstep.LogLineObserver):
    _func_line_re = re.compile(r'  (\w+):\s*(\.|F): \(([0-9]+\.[0-9]+)\)')
    _name_line_re = re.compile(r'  test: (.*) :\s*(\.|F): \(([0-9]+\.[0-9]+)\)')
    tests = 0
    time = 0.0

    def outLineReceived(self, line):
        m = self._func_line_re.search(line.strip())
        if m:
            name, result, time = m.groups()
            self.tests += 1
            self.time += float(time)
            self.step.setProgress('tests', self.tests)
            self.step.setProgress('time', self.time)
        else:
            m = self._name_line_re.search(line.strip())
            if m:
                name, result, time = m.groups()
                self.tests += 1
                self.time += float(time)
                self.step.setProgress('tests', self.tests)
                self.step.setProgress('time', self.time)

def all_driver_tests(**kwargs):
    python_step = shell.Test(name='python',
                             descriptionSuffix=['python'],
                             command=['nosetests', '-v'],
                             workdir='mongo-python-driver',
                             **kwargs)
    python_step.addLogObserver('stdio', PymongoLogObserver())
    python_step.progressMetrics += ('tests',)

    ruby_step = shell.Test(name='ruby',
                           descriptionSuffix=['ruby'],
                           command=['bash', '-c',
                                    ' ; '.join(['if [[ -f "$HOME/.rvm/scripts/rvm" ]]; then source "$HOME/.rvm/scripts/rvm"; fi',
                                                'if [[ -f "/usr/local/rvm/scripts/rvm" ]]; then source /usr/local/rvm/scripts/rvm; fi',
                                                'rake test:ext test:ruby TESTOPTS="-v"'])],
                           workdir='mongo-ruby-driver',
                           warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                           warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                           suppressionFile='buildbot/compile.suppressions',
                           **kwargs)
    ruby_step.addLogObserver('stdio', RubyLogObserver())
    ruby_step.progressMetrics += ('tests', 'time')
    return [python_step,
            ruby_step,
            shell.Test(name='java',
                       descriptionSuffix=['java'],
                       command=['mvn', 'test'],
                       workdir='mongo-java-driver',
                       **kwargs),
            shell.Test(name='perl',
                       descriptionSuffix=['perl'],
                       command=['bash', '-c',
                                ' ; '.join(['if [[ -f "$HOME/perl5/perlbrew/etc/bashrc" ]]; then source "$HOME/perl5/perlbrew/etc/bashrc"; fi',
                                            'dzil test'])],
                       workdir='mongo-perl-driver',
                       warningPattern="^(.\*?):([0-9]+): [Ww]arning: (.\*)$",
                       warningExtractor=shell.Compile.warnExtractFromRegexpGroups,
                       suppressionFile='buildbot/compile.suppressions',
                       **kwargs)]

single_server_logs = {'server': '/tmp/mongo-test-server.log'}

start_single_server = [slave.RemoveDirectory(dir='/data/db', hideStepIf=True, haltOnFailure=False, flunkOnFailure=False),
                       slave.MakeDirectory(dir='/data/db', hideStepIf=success),
                       shell.ShellCommand(name='start single server',
                                          description=['starting', 'single', 'server'],
                                          descriptionDone=['start', 'single', 'server'],
                                          command=['mongo-tarball/bin/mongod', '--fork', '--logpath', '/tmp/mongo-test-server.log'],
                                          logfiles=single_server_logs,
                                          hideStepIf=success,
                                          haltOnFailure=True),
                       shell.ShellCommand(
                           name='check server',
                           description=['checking', 'server'],
                           descriptionDone=['check', 'server'],
                           command=['bash', '-c',
                                    'for i in `seq 1 60`; do if ./mongo --quiet --eval "db.version()"; then exit 0; fi; sleep 1; done; exit 1'],
                           logfiles=single_server_logs,
                           hideStepIf=success,
                           haltOnFailure=True)]
stop_single_server = shell.ShellCommand(name='stop single server',
                                        description=['stopping', 'single', 'server'],
                                        descriptionDone=['stop', 'single', 'server'],
                                        command=['mongo-tarball/bin/mongod', '--shutdown'],
                                        logfiles=single_server_logs,
                                        hideStepIf=success,
                                        alwaysRun=True)

rs_logs = {'db0': '/tmp/mongo-test-server-db0.log',
           'db1': '/tmp/mongo-test-server-db1.log',
           'db2': '/tmp/mongo-test-server-db2.log'}

def start_replica_set(rs_num, basedir='/data/db', base_port=27017):
    rs_name='rs%d' % rs_num
    steps = []
    bash_commands = []
    rs_logs = {}
    for db_num in [0, 1, 2]:
        port=base_port + db_num
        d_name='%s-db%d' % (rs_name, db_num)
        dbpath='%s/%s' % (basedir, d_name)
        logpath='/tmp/mongo-test-server-%s.log' % d_name
        rs_logs[d_name] = logpath
        steps.append(slave.RemoveDirectory(dir=dbpath, hideStepIf=True, haltOnFailure=False, flunkOnFailure=False))
        steps.append(slave.MakeDirectory(dir=dbpath, hideStepIf=success))
        bash_commands.append(' '.join(['./mongod',
                                       '--replSet=%s' % rs_name,
                                       '--port=%d' % port,
                                       '--dbpath=%s' % dbpath,
                                       '--logpath=%s' % logpath,
                                       '--fork']))
    rs_config = ("{_id: '%s', version: 1, members: [%s]}" %
                 (rs_name,
                  ','.join(("{_id: %d, host: 'localhost:%d'}" %
                            (x, base_port + x))
                           for x in [0, 1, 2])))
    bash_commands.append('./mongo --port=%d --eval "var i = 0; while (!rs.initiate(%s).ok) { assert.lt(++i, 60); sleep(1000); }"' % (base_port, rs_config))
    bash_commands.append('./mongo --port=%d --eval "var i = 0; while (!db.adminCommand(\'ismaster\').ismaster) { assert.lt(++i, 60); sleep(1000); }"' % base_port)
    for db_num in [1, 2]:
        bash_commands.append('./mongo --port=%d --eval "var i = 0; while (!db.adminCommand(\'ismaster\').secondary) { assert.lt(++i, 60); sleep(1000); }"' % (base_port + db_num))

    steps.append(shell.ShellCommand(
        name='start replica set',
        description=['starting', 'replica', 'set'],
        descriptionDone=['start', 'replica', 'set'],
        command=['bash', '-c', ' && '.join(bash_commands)],
        logfiles=rs_logs,
        hideStepIf=success,
        haltOnFailure=True))
    return steps, rs_logs

def stop_replica_set(rs_logs, base_port=27017):
    bash_commands = []
    for db_num in [1, 2, 0]:
        bash_commands.append(' '.join(['./mongo', '--port=%d' % (base_port + db_num), '--eval', '"db.adminCommand({shutdown: 1, force: true})"']))
    return shell.ShellCommand(
        name='stop replica set',
        description=['stopping', 'replica', 'set'],
        descriptionDone=['stop', 'replica', 'set'],
        command=['bash', '-c',
                 ' ; '.join(bash_commands + ['true'])],
        alwaysRun=True,
        hideStepIf=success,
        flunkOnFailure=False,
        haltOnFailure=False,
        logfiles=rs_logs)

def start_sharded_cluster(base_port=10000):
    basedir='/data/db/sharding'
    steps = []
    sh_logs = {}
    for rs_num in [0, 1, 2]:
        rs_base_port = base_port + (10 * rs_num)
        rs_steps, rs_logs = start_replica_set(rs_num, basedir, rs_base_port)
        steps.extend(rs_steps)
        sh_logs.update(rs_logs)
    for cfg_num in [0, 1, 2]:
        cfg_port = base_port + 100 + cfg_num
        d_name = 'cfg%d' % cfg_num
        dbpath = '%s/%s' % (basedir, d_name)
        logpath = '/tmp/mongo-test-server-%s.log' % d_name
        sh_logs[d_name] = logpath
        steps.append(slave.RemoveDirectory(dir=dbpath, hideStepIf=True, haltOnFailure=False, flunkOnFailure=False))
        steps.append(slave.MakeDirectory(dir=dbpath, hideStepIf=success))
        steps.append(shell.ShellCommand(
            name='start config server %d' % cfg_num,
            description=['starting', 'config', 'server'],
            descriptionDone=['start', 'config', 'server'],
            command=['./mongod',
                     '--port=%d' % cfg_port,
                     '--dbpath=%s' % dbpath,
                     '--logpath=%s' % logpath,
                     '--logappend',
                     '--configsvr',
                     '--fork'],
            logfiles={d_name: logpath},
            hideStepIf=success,
            haltOnFailure=True))
        steps.append(shell.ShellCommand(
            name='check config server %d' % cfg_num,
            description=['checking', 'config', 'server'],
            descriptionDone=['check', 'config', 'server'],
            command=['bash', '-c',
                     'for i in `seq 1 60`; do if ./mongo localhost:%d --quiet --eval "db.version()"; then exit 0; fi; sleep 1; done; exit 1' % cfg_port],
            logfiles={d_name: logpath},
            hideStepIf=success,
            haltOnFailure=True))
    logpath = '/tmp/mongo-test-server-mongos.log'
    sh_logs['mongos'] = logpath
    steps.append(shell.ShellCommand(
        name='start router',
        description=['starting', 'router'],
        descriptionDone=['start', 'router'],
        command=['./mongos', '--fork',
                 '--configdb', ','.join('localhost:%d' % (base_port + 100 + cfg_num) for cfg_num in [0, 1, 2]),
                 '--logpath', logpath,
                 '--logappend'],
        logfiles=sh_logs,
        hideStepIf=success,
        haltOnFailure=True))
    for rs_num in [0, 1, 2]:
        rs_name = 'rs%d' % rs_num
        rs_port = base_port + (10 * rs_num)
        steps.append(shell.ShellCommand(
            name='add shard %s' % rs_name,
            description=['adding', 'shard'],
            descriptionDone=['add', 'shard'],
            command=['./mongo', '--eval', "sh.addShard('%s/localhost:%d')" % (rs_name, rs_port)],
            logfiles=sh_logs,
            hideStepIf=success,
            haltOnFailure=True))

    return steps, sh_logs

def stop_sharded_cluster(sh_logs, base_port=10000):
    commands = []
    commands.append(' '.join(['./mongo', '--eval', '"db.adminCommand({shutdown: 1, force: true})"']))
    for cfg_num in [0, 1, 2]:
        cfg_port = base_port + 100 + cfg_num
        commands.append(' '.join(['./mongo', '--port=%d' % cfg_port, '--eval', '"db.adminCommand({shutdown: 1, force: true})"']))

    steps = []
    steps.append(shell.ShellCommand(
        name='stop mongos',
        description=['stopping', 'mongos'],
        descriptionDone=['stop', 'mongos'],
        command=['bash', '-c', ' ; '.join(commands + ['true'])],
        logfiles=sh_logs,
        alwaysRun=True,
        hideStepIf=success,
        flunkOnFailure=False,
        haltOnFailure=True))

    for rs_num in [0, 1, 2]:
        rs_base_port = base_port + (10 * rs_num)
        rs_logs = {x: sh_logs[x] for x in ('rs%d-db%d' % (rs_num, db_num) for db_num in [0, 1, 2])}
        steps.append(stop_replica_set(rs_logs, rs_base_port))

    return steps

driver_test_lock = locks.SlaveLock('driver_test_lock', maxCount=8)

driver_test_factory = factory.BuildFactory()
driver_test_factory.addSteps(checkout_steps)
driver_test_factory.addSteps(just_driver_repos)
driver_test_factory.addSteps(get_tarball)
driver_test_factory.addSteps(unpack_tarball)
driver_test_factory.addStep(shell.ShellCommand(
    name='kill servers',
    description=['killing', 'servers'],
    descriptionDone=['kill', 'servers'],
    command=['bash', '-c', 'killall mongos mongod ; sleep 15 ; killall -9 mongos mongod'],
    flunkOnFailure=False, haltOnFailure=False, hideStepIf=True))
driver_test_factory.addStep(shell.ShellCommand(
    name='cleanbb',
    descriptionSuffix=['cleanbb'],
    command=['python2', 'buildscripts/cleanbb.py', '../mongo-ruby-driver/data'],
    flunkOnFailure=False, haltOnFailure=False, hideStepIf=True))
driver_test_factory.addSteps(start_single_server)
driver_test_factory.addSteps(all_driver_tests(logfiles=single_server_logs))
driver_test_factory.addStep(stop_single_server)
if False:
    driver_test_factory.addStep(shell.Test(name='ruby rs',
                                       descriptionSuffix=['ruby', 'rs'],
                                       command=['bash', '-c',
                                                ' ; '.join(['if [[ -f "$HOME/.rvm/scripts/rvm" ]]; then source "$HOME/.rvm/scripts/rvm"; fi',
                                                            'if [[ -f "/usr/local/rvm/scripts/rvm" ]]; then source /usr/local/rvm/scripts/rvm; fi',
                                                            'rake test:replica_set TESTOPTS="-v"'])],
                                       workdir='mongo-ruby-driver',
                                       env={'PATH': "../build:${PATH}"},
                                       logfiles={'mongods-3000': 'data/mongods-3000/mongods.log',
                                                 'mongods-3001': 'data/mongods-3001/mongods.log',
                                                 'mongods-3002': 'data/mongods-3002/mongods.log'}))
driver_test_factory.addStep(shell.Test(name='ruby sh',
                                       descriptionSuffix=['ruby', 'sh'],
                                       command=['bash', '-c',
                                                ' ; '.join(['if [[ -f "$HOME/.rvm/scripts/rvm" ]]; then source "$HOME/.rvm/scripts/rvm"; fi',
                                                            'if [[ -f "/usr/local/rvm/scripts/rvm" ]]; then source /usr/local/rvm/scripts/rvm; fi',
                                                            'rake test:sharded_cluster TESTOPTS="-v"'])],
                                       workdir='mongo-ruby-driver',
                                       env={'PATH': "../build:${PATH}"},
                                       logfiles={'mongods-3000': 'data/mongods-3000/mongods.log',
                                                 'mongods-3001': 'data/mongods-3001/mongods.log',
                                                 'mongods-3002': 'data/mongods-3002/mongods.log',
                                                 'routers-3003': 'data/routers-3003/routers.log',
                                                 'routers-3004': 'data/routers-3004/routers.log',
                                                 'routers-3005': 'data/routers-3005/routers.log',
                                                 'routers-3006': 'data/routers-3006/routers.log'}))
rs_steps, rs_logs = start_replica_set(0)
driver_test_factory.addSteps(rs_steps)
driver_test_factory.addSteps(all_driver_tests(logfiles=rs_logs))
driver_test_factory.addStep(stop_replica_set(rs_logs))
sh_steps, sh_logs = start_sharded_cluster()
driver_test_factory.addSteps(sh_steps)
driver_test_factory.addSteps(all_driver_tests(logfiles=sh_logs))
driver_test_factory.addSteps(stop_sharded_cluster(sh_logs))

continuous_test_factory = factory.BuildFactory()
continuous_test_factory.addSteps(checkout_steps)
continuous_test_factory.addSteps(build_ft_index)
continuous_test_factory.addSteps(build_backup)
continuous_test_factory.addSteps(get_tarball)
continuous_test_factory.addSteps(cpp_tests)
continuous_test_factory.addStep(build_test_extras)
continuous_test_factory.addSteps(unpack_tarball)
continuous_test_factory.addSteps(smoke_suite('js', False))
continuous_test_factory.addSteps(smoke_suite('js', True))

# TODO: add parallel
all_js_test_suites = ['js', 'failPoint', 'tool', 'auth', 'aggregation', 'sharding', 'replSets', 'jsSlowNightly']

release_test_factory = factory.BuildFactory()
release_test_factory.addSteps(checkout_steps)
release_test_factory.addSteps(build_ft_index)
release_test_factory.addSteps(build_backup)
release_test_factory.addSteps(get_tarball)
release_test_factory.addSteps(cpp_tests)
release_test_factory.addStep(build_test_extras)
release_test_factory.addSteps(unpack_tarball)

for suite in all_js_test_suites:
    release_test_factory.addSteps(smoke_suite(suite, False))
    release_test_factory.addSteps(smoke_suite(suite, True))

coverage_test_factory = factory.BuildFactory()
coverage_test_factory.addSteps(checkout_steps)
coverage_test_factory.addSteps(build_ft_index)
coverage_test_factory.addSteps(build_backup)
coverage_test_factory.addStep(build_mongo)
for suite in all_js_test_suites:
    coverage_test_factory.addSteps(smoke_suite(suite, False))
    coverage_test_factory.addSteps(smoke_suite(suite, True))

def _coverage_id(props):
    return '%s-%d' % (props.getProperty('buildername'), props.getProperty('buildnumber'))
@properties.renderer
def coverage_test_html_out_dir(props):
    return 'coverage_out-%s' % _coverage_id(props)
@properties.renderer
def coverage_test_upload_dir(props):
    return 'public_html/coverage/%s' % _coverage_id(props)
@properties.renderer
def coverage_test_url(props):
    return 'http://lex1:8020/%s' % _coverage_id(props)
coverage_test_factory.addStep(shell.ShellCommand(name='lcov',
                                                 descriptionSuffix=['lcov'],
                                                 command=['lcov',
                                                          '--directory', 'build/linux2/cc_gcc-4.6/cxx_g++-4.6/dd/gcov/mongo',
                                                          '--base-directory', '.',
                                                          '--gcov-tool', 'gcov-4.6',
                                                          #'--no-external',
                                                          '-c', '-o', 'lcov.out']))
coverage_test_factory.addStep(slave.MakeDirectory(dir=coverage_test_html_out_dir, hideStepIf=success))
coverage_test_factory.addStep(shell.ShellCommand(name='genhtml',
                                                 descriptionSuffix=['genhtml'],
                                                 command=['genhtml',
                                                          '--output-directory', coverage_test_html_out_dir,
                                                          'lcov.out']))
coverage_test_factory.addStep(transfer.DirectoryUpload(slavesrc=coverage_test_html_out_dir,
                                                       masterdest=coverage_test_upload_dir,
                                                       url=coverage_test_url))
coverage_test_factory.addStep(slave.RemoveDirectory(dir=coverage_test_html_out_dir, hideStepIf=success,
                                                    alwaysRun=True, haltOnFailure=False, flunkOnFailure=False))

def single_suite():
    prefix = properties.Interpolate('--smoke-db-prefix=smoke-%(prop:buildername)s-%(prop:suite)s%(prop:auth:#?|-auth|)s')
    @properties.renderer
    def getCmd(step):
        cmd = ['python2',
               'buildscripts/smoke.py',
               prefix,
               port,
               '--continue-on-failure',
               '--quiet',
               '--smoke-server-opts=--logappend']
        props = step.build.getProperties()
        if props.hasProperty('auth') and props.getProperty('auth'):
            cmd.append('--auth')
        cmd.append(properties.Property('suite'))
        return cmd

    step = shell.Test(name='suite',
                      descriptionSuffix=['suite'],
                      command=getCmd,
                      locks=[sets_lock.access('exclusive')],
                      timeout=7200,
                      warningPattern=re.compile(r'(?!)'),  # matches no string, we don't want to see warnings from the mongod error log
                      logfiles={'tests': properties.Interpolate('smoke-%(prop:buildername)s-%(prop:suite)s/tests.log'),
                                'server': properties.Interpolate('smoke-%(prop:buildername)s-%(prop:suite)s/server.log')},
                      env=properties.Property('env'))
    step.addLogObserver('stdio', TAPLogObserver())
    step.progressMetrics += ('tests',)
    return [slave.MakeDirectory(dir=properties.Interpolate('build/smoke-%(prop:buildername)s-%(prop:suite)s'), hideStepIf=success),
            step,
            slave.RemoveDirectory(dir=properties.Interpolate('build/smoke-%(prop:buildername)s-%(prop:suite)s'), hideStepIf=True, alwaysRun=True, haltOnFailure=False, flunkOnFailure=False)]

js_test_factory = factory.BuildFactory()
js_test_factory.addSteps(checkout_steps)
js_test_factory.addSteps(build_ft_index)
js_test_factory.addSteps(build_backup)
js_test_factory.addSteps(get_tarball)
js_test_factory.addStep(build_test_extras)
js_test_factory.addSteps(unpack_tarball)
js_test_factory.addSteps(single_suite())

def nightly_trigger_factory(pfx, enterprise):
    f = factory.BuildFactory()
    f.addStep(trigger.Trigger(schedulerNames=['%snightly_test-%s' % (pfx, 'e' if enterprise else 'c')],
                              hideStepIf=True,
                              haltOnFailure=True,
                              updateSourceStamp=True))
    return f

from buildbot import config

ver_branch_map = {
    'master': ('master', ''),
    '1.2': ('releases/tokumx-1.2', '1.2-'),
    '1.3': ('releases/tokumx-1.3', '1.3-')
}

base_port_inc = 0
c['builders'] = []
for rel in ['e', 'c']:
    enterprise = rel == 'e'
    for type in ['dbg', 'opt']:
        is_debug = type == 'dbg'
        for kind, tpl in ver_branch_map.items():
            branch, pfx = tpl
            base_port_inc += 2000

            c['builders'].append(
                config.BuilderConfig(name='%scompile-linux-%s-%s' % (pfx, rel, type),
                                     slavenames=vms,
                                     properties={'debugbuild': is_debug,
                                                 'enterprise': enterprise},
                                     factory=quick_compile_factory,
                                     category=kind))

            extra_port_inc = base_port_inc + (0 if is_debug else 200)
            extra_port_inc += 0 if enterprise else 100
            c['builders'].append(
                config.BuilderConfig(name='%scontinuous_test-linux-%s-%s' % (pfx, rel, type),
                                     slavenames=vms,
                                     properties={'debugbuild': is_debug,
                                                 'enterprise': enterprise,
                                                 'port_inc': 0 + extra_port_inc},
                                     factory=continuous_test_factory,
                                     locks=[driver_test_lock.access('counting')],
                                     category=kind))

            if is_debug:  # only need one of these
                c['builders'].append(
                    config.BuilderConfig(name='%snightly_trigger-%s' % (pfx, rel),
                                         slavenames=['lex1'],
                                         properties={'enterprise': enterprise},
                                         factory=nightly_trigger_factory(pfx, enterprise),
                                         category='utils'))

            c['builders'].append(
                config.BuilderConfig(name='%snightly_test-linux-%s-%s' % (pfx, rel, type),
                                     slavenames=vms,
                                     properties={'debugbuild': is_debug,
                                                 'enterprise': enterprise,
                                                 'port_inc': 400 + extra_port_inc},
                                     factory=release_test_factory,
                                     locks=[driver_test_lock.access('counting')],
                                     category=kind))

            c['builders'].append(
                config.BuilderConfig(name='%sdriver_test-linux-%s-%s' % (pfx, rel, type),
                                     slavenames=vms,
                                     properties={'debugbuild': is_debug,
                                                 'enterprise': enterprise},
                                     factory=driver_test_factory,
                                     locks=[driver_test_lock.access('exclusive')],
                                     category=kind))

        c['builders'].append(
            config.BuilderConfig(name='release_build-%s-%s' % (rel, type),
                                 slavenames=['lex1'],
                                 properties={'debugbuild': is_debug,
                                             'enterprise': enterprise},
                                 factory=build_tarball_and_trigger_test_factory(enterprise, is_debug),
                                 category='release'))

        c['builders'].append(
            config.BuilderConfig(name='release_test-linux-%s-%s' % (rel, type),
                                 slavenames=vms,
                                 properties={'debugbuild': is_debug,
                                             'enterprise': enterprise,
                                             'port_inc': 2000 + extra_port_inc},
                                 factory=release_test_factory,
                                 locks=[driver_test_lock.access('counting')],
                                 category='release'))
        c['builders'].append(
            config.BuilderConfig(name='release_driver_test-linux-%s-%s' % (rel, type),
                                 slavenames=vms,
                                 properties={'debugbuild': is_debug,
                                             'enterprise': enterprise},
                                 factory=driver_test_factory,
                                 locks=[driver_test_lock.access('exclusive')],
                                 category='release'))

c['builders'].append(
    config.BuilderConfig(name='tarball',
                         slavenames=['lex1'],
                         factory=build_tarball_factory(),
                         category='utils'))

single_js_test_lock = locks.SlaveLock('single_js_test_lock')
c['builders'].append(
    config.BuilderConfig(name='single_js_test-linux',
                         slavenames=vms,
                         properties={'port_inc': 10000},
                         locks=[driver_test_lock.access('counting'),
                                single_js_test_lock.access('exclusive')],
                         factory=js_test_factory,
                         category='utils'))

c['builders'].append(
    config.BuilderConfig(name='coverage_test-linux',
                         slavenames=mindy_slaves,
                         properties={'debugbuild': True,
                                     'coveragebuild': True,
                                     'port_inc': 12000},
                         factory=coverage_test_factory,
                         locks=[driver_test_lock.access('counting')],
                         category='master'))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers import basic, forcesched, timed, triggerable

c['schedulers'] = []
c['schedulers'].append(forcesched.ForceScheduler(
    name='force-js',
    codebases=all_codebases,
    builderNames=['single_js_test-linux'],
    properties=[forcesched.BooleanParameter('debugbuild', 'debugbuild', required=True),
                forcesched.BooleanParameter('enterprise', 'enterprise', required=True),
                forcesched.BooleanParameter('auth', 'auth', required=True),
                forcesched.ChoiceStringParameter('suite', 'suite', required=True,
                                                 choices=['js', 'failPoint', 'tool', 'auth', 'parallel', 'jsPerf', 'aggregation', 'failPoint', 'ssl', 'sharding', 'replSets', 'multiVersion', 'jsSlowNightly', 'jsSlowWeekly'])]
    ))
c['schedulers'].append(forcesched.ForceScheduler(
    name='force-coverage',
    codebases=all_codebases,
    builderNames=['coverage_test-linux'],
    properties=[forcesched.BooleanParameter('enterprise', 'enterprise', required=True)]
    ))

for rel in ['c', 'e']:
    enterprise = rel == 'e'
    for kind, tpl in ver_branch_map.items():
        branch, pfx = tpl
        c['schedulers'].append(basic.SingleBranchScheduler(
            name='%scompile-%s' % (pfx, rel),
            codebases=gen_codebases(branch, enterprise, False),
            branch=branch,
            treeStableTimer=5*60,
            builderNames=['%scompile-linux-%s-%s' % (pfx, rel, type) for type in ['opt', 'dbg']]))
        c['schedulers'].append(basic.SingleBranchScheduler(
            name='%scontinuous_test-%s' % (pfx, rel),
            codebases=gen_codebases(branch, enterprise, False),
            branch=branch,
            treeStableTimer=60*60,
            builderNames=['%scontinuous_test-linux-%s-%s' % (pfx, rel, type) for type in ['opt', 'dbg']]))
        c['schedulers'].append(basic.SingleBranchScheduler(
            name='%sdriver_test-%s' % (pfx, rel),
            codebases=gen_codebases(branch, enterprise, True),
            branch=branch,
            treeStableTimer=60*60,
            builderNames=['%sdriver_test-linux-%s-%s' % (pfx, rel, type) for type in ['opt', 'dbg']]))
        c['schedulers'].append(basic.SingleBranchScheduler(
            name='%snightly_trigger-%s' % (pfx, rel),
            codebases=gen_codebases(branch, enterprise, True),
            branch=branch,
            treeStableTimer=5*60,
            builderNames=['%snightly_trigger-%s' % (pfx, rel)]))
        c['schedulers'].append(timed.NightlyTriggerable(
            name='%snightly_test-%s' % (pfx, rel),
            codebases=gen_codebases(branch, enterprise, False),
            hour=0, minute=0,
            builderNames=['%snightly_test-linux-%s-%s' % (pfx, rel, type) for type in ['opt', 'dbg']]))
    for type in ['opt', 'dbg']:
        c['schedulers'].append(triggerable.Triggerable(
            name='release_test-%s-%s' % (rel, type),
            codebases=all_codebases,
            builderNames=['release_%s-linux-%s-%s' % (build, rel, type) for build in ['test', 'driver_test']]))

c['schedulers'].append(forcesched.ForceScheduler(
    name='force-release',
    codebases=all_codebases,
    builderNames=['release_build-%s-%s' % (rel, type)
                  for rel in ['c', 'e']
                  for type in ['opt', 'dbg']],
    properties=[forcesched.StringParameter('distname', 'distname', required=True)]
    ))
c['schedulers'].append(forcesched.ForceScheduler(
    name='force',
    codebases=all_codebases,
    builderNames=['tarball'] + filter(None, ['%s%s-linux-%s-%s' % (pfx, build, rel, type)
                                             for build in ['compile', 'continuous_test', 'nightly_test', 'driver_test']
                                             for rel in ['c', 'e']
                                             for type in ['opt', 'dbg']
                                             for pfx in [p[1] for p in ver_branch_map.values()]])))
c['schedulers'].append(triggerable.Triggerable(
    name='tarball',
    codebases=all_codebases,
    builderNames=['tarball']))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth(secrets.webusers.items()),
    gracefulShutdown = False,
    forceBuild = 'auth', # use this to test your slave once it is set up
    forceAllBuilds = 'auth',
    pingBuilder = False,
    stopBuild = 'auth',
    stopAllBuilds = 'auth',
    cancelPendingBuild = 'auth',
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg, order_console_by_time=True))

from buildbot.status import words

c['status'].append(words.IRC(host="irc.freenode.org", nick="bobot", channels=["#tokutek-bbtest"]))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "TokuMX"
c['titleURL'] = "http://github.com/Tokutek/mongo"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://localhost:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
